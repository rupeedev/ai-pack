# Dates and times

The** **`neo4j` package provides types for working with dates and times in Go.

Temporal types in Neo4j are a combination of date, time and timezone elements.

Learn how to interact with Neo4j from Go using the Neo4j Go DriverTemporal Types| Type | Description | Date? | Time? | Timezone? |
| - | - | - | - | - |
| ----------------------------------------------------------- |

| `neo4j.Date`          | A tuple of Year, Month and Day                    | Y |   |   |
| ----------------------- | ------------------------------------------------- | - | - | - |
| `neo4j.OffsetTime`    | The time of the day with a UTC offset             |   | Y | Y |
| `neo4j.LocalTime`     | A time without a timezone                         |   | Y |   |
| `time.Time`           | A combination of Date and Time                    | Y | Y | Y |
| `neo4j.LocalDateTime` | A combination of Date and Time without a timezone | Y | Y |   |
| `neo4j.Duration`      | A period of time                                  |   |   |   |

## Writing temporal types

go

Copy

```go
res, err := neo4j.ExecuteQuery(ctx, driver, `
CREATE (e:Event {
  startsAt: $datetime,              // (1)
  createdAt: datetime($dtstring),   // (2)
  updatedAt: datetime()             // (3)
})
`,
    map[string]any{
        "datetime": func() time.Time {
            loc, _ := time.LoadLocation("Europe/Paris")
            return time.Date(2024, 5, 15, 14, 30, 0, 0, loc)
        }(), // (4)
        "dtstring": "2024-05-15T14:30:00+02:00",
    },
    neo4j.EagerResultTransformer,
)
```

When you write temporal types to the database, you can pass Go time objects as parameters to the query or cast the value within a Cypher statement.

This example demonstrates how to:

1. Use a** **`time.Time` object as a parameter to the query (`<4>`)
2. Cast an** **`datetime` with an** **[IANA timezone identifier](https://www.iana.org/time-zones) within the Cypher statement
3. Get the current date and time using the** **`datetime()` function.

## Reading temporal types

When reading temporal types from the database, you will receive an instance of the corresponding Go type unless you cast the value within your query.

go

Copy

```go
// Query returning temporal types
result, err := neo4j.ExecuteQuery(ctx, driver, `
RETURN date() as date, time() as time, datetime() as datetime, toString(datetime()) as asString
`, nil, neo4j.EagerResultTransformer)

// Access the first record
for _, record := range result.Records {
    // Automatic conversion to Go driver types
    date, _ := record.Get("date")           // neo4j.Date
    time, _ := record.Get("time")           // neo4j.OffsetTime
    datetime, _ := record.Get("datetime")   // time.Time
    asString, _ := record.Get("asString")   // string
}
```

## Working with Durations

go

Copy

```go
startsAt := time.Now()
eventLength := neo4j.DurationOf(0, 0, int64((time.Hour + 30*time.Minute).Seconds()), 0)
endsAt := startsAt.Add(time.Hour + 30*time.Minute)

neo4j.ExecuteQuery(ctx, driver, `
CREATE (e:Event {
  startsAt: $startsAt, endsAt: $endsAt,
  duration: $eventLength, // (1)
  interval: duration('P30M') // (2)
})`,
    map[string]any{
        "startsAt": startsAt,
        "endsAt": endsAt,
        "eventLength": eventLength,
    },
    neo4j.EagerResultTransformer,
)
```

Durations represent a period of time and can be used for date arithmetic in both Go and Cypher. These types can also be created in Go or cast within a Cypher statement.

1. Pass an instance of** **`neo4j.Duration` to the query
2. Use the** **`duration()` function to create a** **`Duration` object from an ISO 8601 format string

Neo4j Duration vs Go Duration

Note the distinction between** **`neo4j.Duration` and Goâ€™s** **`time.Duration`:

* `neo4j.Duration` - Used for storing durations in Neo4j and passing as parameters
* `time.Duration` - Used for Go time calculations like** **`Add()`operations

For time arithmetic in Go, use standard** **`time.Duration` values directly.




# Spatial types

Neo4j has built-in support for two-dimensional and three-dimensional spatial data types. These are referred to as** ** **points** .

A point may represent geographic coordinates (longitude, latitude) or Cartesian coordinates (x, y).

In Go, points are represented by the** **`neo4j.Point2D` and** **`neo4j.Point3D`types, which provide methods to access the coordinates and SRID of the point.

SRID

The** ****Spatial Reference Identifier** (SRID) is a unique identifier used to define the type of coordinate system used.

| Cypher Type                                                                             | Go Type                              | SRID     | 3D SRID  |
| --------------------------------------------------------------------------------------- | ------------------------------------ | -------- | -------- |
| --------------------------------------------------------------------------------------- |                                      |          |          |
| Point (Cartesian)                                                                       | `neo4j.Point2D`/ `neo4j.Point3D` | `7203` | `9157` |
| -                                                                                       | -                                    | -        | -        |
| Point (WGS-84)                                                                          | `neo4j.Point2D`/ `neo4j.Point3D` | `4326` | `4979` |

## CartesianPoint

A Cartesian Point defines a point with x and y coordinates. An additional z value can be provided to define a three-dimensional point.

You can create a cartesian point by creating a** **`neo4j.Point2D` or** **`neo4j.Point3D` struct, or by passing** **`x`,** **`y` and optionally** **`z` values to the point function in Cypher.

go

Copy

```go
import "github.com/neo4j/neo4j-go-driver/v5/neo4j"

// 2D Cartesian point
point2D := neo4j.Point2D{
    X: 1.23,
    Y: 4.56,
    SpatialRefId: 7203, // Cartesian SRID
}

// 3D Cartesian point
point3D := neo4j.Point3D{
    X: 1.23,
    Y: 4.56,
    Z: 7.89,
    SpatialRefId: 9157, // 3D Cartesian SRID
}
```

The driver will convert** **`point` data types created with x, y and z values to instances of the** **`neo4j.Point2D` or** **`neo4j.Point3D` types.

The values can be accessed using the** **`X`,** **`Y`,** **`Z` and** **`SpatialRefId` fields.

go

Copy

```go
result, err := neo4j.ExecuteQuery(ctx, driver, `
RETURN point({x: 1.23, y: 4.56, z: 7.89}) AS threeD
`, nil, neo4j.EagerResultTransformer)

if err == nil && len(result.Records) > 0 {
    point, _ := result.Records[0].Get("threeD")
    if p3d, ok := point.(neo4j.Point3D); ok {
        fmt.Printf("X: %f, Y: %f, Z: %f, SRID: %d\n",
            p3d.X, p3d.Y, p3d.Z, p3d.SpatialRefId)
    }
}
```

## WGS84Point

A WGS** ***(World Geodetic System)* point consists of longitude (`X`) and latitude (`Y`) values. An additional height (`Z`) value can be provided to define a three-dimensional point.

You can create a WGS84 point by creating a** **`neo4j.Point2D` or** **`neo4j.Point3D` struct with the appropriate SRID, or by passing** **`longitude`,** **`latitude` and** **`height` values to the point function in Cypher.

go

Copy

```go
// London coordinates (2D)
london := neo4j.Point2D{
    X: -0.118092,  // longitude
    Y: 51.509865,  // latitude
    SpatialRefId: 4326, // WGS-84 SRID
}

// The Shard with height (3D)
shard := neo4j.Point3D{
    X: -0.086500,  // longitude
    Y: 51.504501,  // latitude
    Z: 310,        // height in meters
    SpatialRefId: 4979, // WGS-84 3D SRID
}
```

The driver will return** **`neo4j.Point2D` or** **`neo4j.Point3D` objects when** **`point` data types are created with** **`latitude` and** **`longitude` values in Cypher.

go

Copy

```go
result, err := neo4j.ExecuteQuery(ctx, driver, `
RETURN point({ latitude: 51.5, longitude: -0.118, height: 100 }) AS point
`, nil, neo4j.EagerResultTransformer)

if err == nil && len(result.Records) > 0 {
    point, _ := result.Records[0].Get("point")
    if p3d, ok := point.(neo4j.Point3D); ok {
        longitude := p3d.X
        latitude := p3d.Y
        height := p3d.Z
        srid := p3d.SpatialRefId
        fmt.Printf("Lon: %f, Lat: %f, Height: %f, SRID: %d\n",
            longitude, latitude, height, srid)
    }
}
```

## Distance

The** **`point.distance` function can be used to calculate the distance between two points with the same SRID.

The result is a** **`float64` representing the distance in a straight line between the two points.

SRIDs must be compatible

If the SRID values are different, the function will return an error.

go

Copy

```go
// Create two Cartesian points
point1 := neo4j.Point2D{X: 1.23, Y: 4.56, SpatialRefId: 7203}
point2 := neo4j.Point2D{X: 2.34, Y: 5.67, SpatialRefId: 7203}

// Query the distance using Cypher
result, err := neo4j.ExecuteQuery(ctx, driver, `
RETURN point.distance($p1, $p2) AS distance
`, map[string]any{
    "p1": point1,
    "p2": point2,
}, neo4j.EagerResultTransformer)

if err == nil && len(result.Records) > 0 {
    distance, _ := result.Records[0].Get("distance")
    fmt.Printf("Distance: %f\n", distance.(float64))
}
```

Advance to challenge
