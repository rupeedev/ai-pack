# Executing Cypher statements

## Introduction

You can use the** **`neo4j.ExecuteQuery()` function to run one-off Cypher statements or statements that return a small number of records. This function fetches a list of records and loads them into memory.

go

Copy

```go
cypher := `
MATCH (a:Person {name: $name})-[r:ACTED_IN]->(m:Movie)
RETURN a.name AS name, m.title AS title, r.role AS role
`
name := "Tom Hanks"

result, err := neo4j.ExecuteQuery(ctx, driver, // (1)
    cypher,    // (2)
    map[string]any{"name": name}, // (3)
    neo4j.EagerResultTransformer, // (4)
)
```

1. The function returns a result object and an error.
2. The function expects a Cypher statement as a string as the first argument.
3. Parameters are passed as a map with string keys and any values.
4. The result transformer determines how results are processed.

Using Parameters

It is good practice to use parameters in your queries to avoid malicious code being injected into your Cypher statement.

## Handling the Result

The** **`neo4j.ExecuteQuery()` function returns a** **`ResultWithContext` object containing:

1. A list of** **`Record` objects
2. Summary information about the query execution
3. Keys specified in the** **`RETURN` clause

go

Copy

```go
fmt.Println(result.Records) // [...]
fmt.Println(result.Keys)  // [title role]
fmt.Println(result.Summary)  // A summary of the query execution
```

## Specifying a database

You can specify a database to query using the** **`ExecuteQueryWithDatabase()`method.

go

Copy

```go
result, err := neo4j.ExecuteQuery(ctx, driver,
    cypher,
    map[string]any{"name": name},
    neo4j.EagerResultTransformer,
    neo4j.ExecuteQueryWithDatabase("recommendations") // Query the 'recommendations' database
)
```

## Accessing results

Each row returned by the query is a** **`Record` object. The** **`Record` object provides access to the data returned by the query.

You can access any item in the** **`RETURN` clause using the** **`Get()` method.

go

Copy

```go
// RETURN a.name AS name, m.title AS title, r.role AS role

for _, record := range result.Records {
    name, _ := record.Get("name")  // Tom Hanks
    title, _ := record.Get("title")  // Toy Story
    role, _ := record.Get("role")    // "Woody"
    fmt.Printf("%s played %s in %s\n", name, role, title) // Tom Hanks played Woody in Toy Story
}
```

## Transforming results

The** **`ExecuteQuery()` method accepts a result transformer as a fourth argument that allows you to transform the result into an alternative format.

go

Copy

```go
roles, err := neo4j.ExecuteQuery(ctx, driver,
    cypher,
    map[string]any{"name": name},
    func(result neo4j.ResultWithContext) (any, error) {
        var roles []string
        for _, record := range result.Records {
            name, _ := record.Get("name")
            title, _ := record.Get("title")
            role, _ := record.Get("role")
            roles = append(roles, fmt.Sprintf("%s played %s in %s", name, role, title))
        }
        return roles, nil
    },
    neo4j.ExecuteQueryWithDatabase("neo4j"), // Specify the database
)
```

The benefit to defining a custom transformer is that you can directly convert the result into a format that can be used directly in your application.

go

Copy

```go
fmt.Println(roles)  // ["Tom Hanks played Woody in Toy Story", ...]
```

This method also allows you to process the results as they are returned, rather than waiting for the final result to be returned.

## Reading and writing

By default,** **`neo4j.ExecuteQuery()` runs in** ****WRITE** mode. In a clustered environment, this sends all queries to the cluster leader, putting unnecessary load on the leader.

When you‚Äôre only reading data, you can optimize performance by setting the routing control to READ mode. This distributes your read queries across all cluster members.

go

Copy

```go
result, err := neo4j.ExecuteQuery(ctx, driver,
    cypher,
    map[string]any{"name": name},
    neo4j.EagerResultTransformer,
    neo4j.ExecuteQueryWithDatabase("neo4j"), // (1)
    neo4j.ExecuteQueryWithReadersRouting(), // (2)
)
```

Combining Options

You can combine multiple options like** **`ExecuteQueryWithDatabase()` and** **`ExecuteQueryWithReadersRouting()` in the same query.




go run . examples)
  ‚éø  ‚úì Connected to Neo4j successfully!
    Connected to Neo4j successfully!
     ========================================
     ‚Ä¶ +69 lines (ctrl+o to expand)

‚è∫ Perfect! I've successfully implemented all the Cypher execution examples from the Neo4j GraphAcademy guide. Here's what we built:

  üìÅ Project Structure

  hello-neo4j/
  ‚îú‚îÄ‚îÄ main.go                    # CLI with commands: basic, setup, examples
  ‚îú‚îÄ‚îÄ cypher_examples.go         # 7 comprehensive Cypher examples
  ‚îú‚îÄ‚îÄ setup_data.go             # Sample data (Movies & Actors)
  ‚îú‚îÄ‚îÄ go.mod / go.sum           # Dependencies
  ‚îú‚îÄ‚îÄ README.md                  # Complete documentation
  ‚îî‚îÄ‚îÄ *.md                      # Deployment guides

  ‚úÖ Implemented Examples

  Example 1: Parameterized Queries ‚úì

- Safely query with parameters (prevents injection)
- Found Tom Hanks in 7 movies

  Example 2: Result Metadata ‚úì

- Access result.Keys, result.Summary
- Get statement type and database info
- Recent movies sorted by release year

  Example 3: Custom Result Transformer ‚úì

- Transform records into custom format
- Created formatted role descriptions

  Example 4: Database Selection ‚úì

- Query specific databases using ExecuteQueryWithDatabase()
- Verified 20 nodes in the "neo4j" database

  Example 5: Read/Write Routing ‚úì

- Read queries: Distributed across cluster members
- Write queries: Go to cluster leader
- Created and deleted test data

  Example 6: Data Type Handling ‚úì

- Access strings, integers, nil values
- Handle missing/optional fields

  Example 7: Error Handling ‚úì

- Caught syntax errors gracefully
- Proper error messages

  üéØ Key Features

  CLI Commands

  go run .              # Basic connection test
  go run . setup        # Populate database with sample data
  go run . examples     # Run all 7 examples
  go run . help         # Show usage

  Sample Data Created

- 10 Movies: Matrix trilogy, Forrest Gump, Toy Story, etc.
- 10 People: Tom Hanks, Keanu Reeves, directors
- 27+ Relationships: ACTED_IN, DIRECTED with roles

  Best Practices Demonstrated

  ‚úÖ Parameter usage (security)‚úÖ Proper error handling‚úÖ Resource cleanup (defer driver.Close())‚úÖ Result iteration patterns‚úÖ Metadata access‚úÖ Read/write optimization for clusters

  üìä Test Results

  All examples executed successfully:

- ‚úì Connected to Neo4j
- ‚úì Sample data created (20 nodes, 27+ relationships)
- ‚úì All 7 examples passed
- ‚úì Error handling verified

  üéì What You Learned

  Based on the 1.1-Exec-Cypher.md guide:

1. ‚úÖ Execute Cypher with neo4j.ExecuteQuery()
2. ‚úÖ Use parameters safely
3. ‚úÖ Handle results and records
4. ‚úÖ Access result metadata
5. ‚úÖ Transform results
6. ‚úÖ Specify databases
7. ‚úÖ Optimize read/write routing

  You now have a complete, working Neo4j Go application with practical examples ready to build upon!

> go run . setup

‚è∫ Bash(go run . setup)
  ‚éø  ‚úì Connected to Neo4j successfully!

    === Setting up sample data ===
     ‚Ä¶ +18 lines (ctrl+o to expand)

‚è∫ Perfect! ‚úÖ Sample data has been successfully set up in your Neo4j database.

  What Was Created

  Database contents:

- 10 Movies - Matrix trilogy, Forrest Gump, Toy Story, Cast Away, Apollo 13, The Da Vinci Code, Cloud Atlas, The Green Mile
- 10 People - Tom Hanks, Keanu Reeves, Carrie-Anne Moss, Laurence Fishburne, Hugo Weaving, Lilly & Lana Wachowski, Robert Zemeckis, Gary Sinise, Robin Wright
- 27+ Relationships - ACTED_IN and DIRECTED connections

  Top movies by cast:

- The Matrix trilogy - 4 actors each (Keanu, Carrie-Anne, Laurence, Hugo)
- Forrest Gump - 3 actors (Tom Hanks, Gary Sinise, Robin Wright)
- Toy Story - 1 actor (Tom Hanks as Woody)

  Next Steps

  Now you can:

# Run all Cypher examples to see the data in action

  go run . examples

# Or explore in Neo4j Browser

  open http://localhost:7474

  Try these Cypher queries in the browser:
  // See all Tom Hanks movies
  MATCH (tom:Person {name: "Tom Hanks"})-[r:ACTED_IN]->(m:Movie)
  RETURN tom.name, r.role, m.title, m.released
  ORDER BY m.released

  // Visualize The Matrix cast
  MATCH path = (p:Person)-[:ACTED_IN]->(m:Movie {title: "The Matrix"})
  RETURN path

  // Find directors and their movies
  MATCH (d:Person)-[:DIRECTED]->(m:Movie)
  RETURN d.name AS director, collect(m.title) AS movies

  Ready to explore! üöÄ

> go run . examples

‚è∫ Bash(go run . examples)
  ‚éø  ‚úì Connected to Neo4j successfully!
    Connected to Neo4j successfully!
     ========================================
     ‚Ä¶ +69 lines (ctrl+o to expand)

‚è∫ Excellent! ‚úÖ All 7 Cypher execution examples ran successfully. Here's what was demonstrated:

  üìä Results Summary

  Example 1: Parameterized Queries ‚úÖ

- Queried Tom Hanks movies using parameters (prevents SQL injection)
- Found: 7 movies including Forrest Gump, Toy Story, Apollo 13, etc.
- Key Learning: Always use map[string]any{"name": value} instead of string concatenation

  Example 2: Result Metadata ‚úÖ

- Accessed result keys, summary, and statement type
- Database: neo4j (20 total nodes)
- Recent movies: Cloud Atlas (2012) ‚Üí Cast Away (2000)
- Key Learning: Use result.Summary.StatementType() and result.Keys

  Example 3: Custom Result Transformer ‚úÖ

- Transformed raw records into formatted strings
- Created numbered list of Tom Hanks roles
- Key Learning: Post-process results for application-specific formats

  Example 4: Database Selection ‚úÖ

- Queried specific database using ExecuteQueryWithDatabase("neo4j")
- Verified: 20 nodes in database
- Key Learning: Neo4j supports multiple databases per instance

  Example 5: Read/Write Routing ‚úÖ

- Read query: Distributed across cluster (fetched Matrix trilogy)
- Write query: Went to cluster leader (created/deleted test movie)
- Key Learning: Use ExecuteQueryWithReadersRouting() for read-only queries to improve cluster performance

  Example 6: Data Type Handling ‚úÖ

- Accessed strings, integers, and optional fields
- Handled missing taglines gracefully
- Key Learning: Always check if values exist before using them

  Example 7: Error Handling ‚úÖ

- Successfully caught Cypher syntax error
- Gracefully recovered and executed valid query
- Key Learning: Always handle errors from ExecuteQuery()

  üéØ Key Takeaways

| Concept          | Example                               | Why Important                  |
| ---------------- | ------------------------------------- | ------------------------------ |
| Parameters       | map[string]any{"name": "Tom"}         | Security (prevents injection)  |
| Error handling   | if err != nil                         | Catch syntax/connection errors |
| Read routing     | ExecuteQueryWithReadersRouting()      | Performance in clusters        |
| Result iteration | for _, record := range result.Records | Process all returned data      |
| Type safety      | value, ok := record.Get("field")      | Handle missing fields          |

  üéì What You've Mastered

  ‚úÖ Connecting to Neo4j with Go‚úÖ Executing Cypher queries safely‚úÖ Handling results and metadata‚úÖ Transforming data for your application‚úÖ Optimizing cluster performance‚úÖ Error handling best practices

  üìñ Next Steps

  Continue learning:

1. ‚úÖ Cypher execution (completed)
2. Next: Working with transactions
3. Next: Session management
4. Next: Building a real application

  Practice exercises:

# Try modifying the examples

# - Change the actor name in Example 1

# - Add more sample data in setup_data.go

# - Create your own custom transformer

# Explore in browser

  open http://localhost:7474

  You now have a solid foundation for building Neo4j applications with Go!
